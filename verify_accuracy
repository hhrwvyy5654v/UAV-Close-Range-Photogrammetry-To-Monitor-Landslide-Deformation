import cv2
import numpy as np
import math

# 四个特征点的世界坐标,单位是毫米
object_3d_points = np.array(([-50, -50, 0],
                            [-50, 50, 0],
                            [50, -50, 0],
                            [50, 50, 0]), dtype=np.double)

# 四个特征点在图像上的对应点坐标
object_2d_point = np.array(([982.75,2183.5],
                            [840.0,2219.0],
                            [963.75,2051.0],
                            [818.75,2083.5]), dtype=np.double)
# 内参矩阵
camera_matrix = np.array(([755.39354935, 0, 504.39208928],
                         [0, 754.16550667, 371.66825215],
                         [0, 0, 1.0]), dtype=np.double)
# 畸变系数
dist_coefs = np.array([2.83890589e-01, -1.65886965e+00,
                      4.88852246e-04, -4.33686303e-04, 3.34750924e+00], dtype=np.double)

# 求解相机位姿
found, rvec, tvec = cv2.solvePnP(
    object_3d_points, object_2d_point, camera_matrix, dist_coefs)
rotM = cv2.Rodrigues(rvec)[0]
camera_postion = -np.matrix(rotM).T * np.matrix(tvec)
print(camera_postion.T)

# 验证根据博客http://www.cnblogs.com/singlex/p/pose_estimation_1.html提供方法求解相机位姿
# 计算相机坐标系的三轴旋转欧拉角，旋转后可以转出世界坐标系。旋转顺序z,y,x
thetaZ = math.atan2(rotM[1, 0], rotM[0, 0])*180.0/math.pi
thetaY = math.atan2(-1.0*rotM[2, 0], math.sqrt(rotM[2, 1]
                    ** 2 + rotM[2, 2]**2))*180.0/math.pi
thetaX = math.atan2(rotM[2, 1], rotM[2, 2])*180.0/math.pi

# 相机坐标系下值
x = tvec[0]
y = tvec[1]
z = tvec[2]
# 进行三次旋转


def RotateByZ(Cx, Cy, thetaZ):
    rz = thetaZ*math.pi/180.0
    outX = math.cos(rz)*Cx - math.sin(rz)*Cy
    outY = math.sin(rz)*Cx + math.cos(rz)*Cy
    return outX, outY


def RotateByY(Cx, Cz, thetaY):
    ry = thetaY*math.pi/180.0
    outZ = math.cos(ry)*Cz - math.sin(ry)*Cx
    outX = math.sin(ry)*Cz + math.cos(ry)*Cx
    return outX, outZ


def RotateByX(Cy, Cz, thetaX):
    rx = thetaX*math.pi/180.0
    outY = math.cos(rx)*Cy - math.sin(rx)*Cz
    outZ = math.sin(rx)*Cy + math.cos(rx)*Cz
    return outY, outZ


(x, y) = RotateByZ(x, y, -1.0*thetaZ)
(x, z) = RotateByY(x, z, -1.0*thetaY)
(y, z) = RotateByX(y, z, -1.0*thetaX)
Cx = x*-1
Cy = y*-1
Cz = z*-1

print("相机位置:",Cx, Cy, Cz)
print("相机旋转角:",thetaX, thetaY, thetaZ)

# 对第五个点进行验证
Out_matrix = np.concatenate((rotM, tvec), axis=1)
pixel = np.dot(camera_matrix, Out_matrix)
pixel1 = np.dot(pixel, np.array([150, 50, 0, 1], dtype=np.double))
pixel2 = pixel1/pixel1[2]
print(pixel2)
